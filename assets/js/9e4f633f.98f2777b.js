"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8469],{2911:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"client/lua-api/lua-cheat-sheet","title":"Lua Cheat Sheet","description":"It\'s not necessary to understand everything on this page, but the more you understand the better you will be at debugging and collaborating.","source":"@site/docs/01-client/04-lua-api/01-lua-cheat-sheet.md","sourceDirName":"01-client/04-lua-api","slug":"/client/lua-api/lua-cheat-sheet","permalink":"/client/lua-api/lua-cheat-sheet","draft":false,"unlisted":false,"editUrl":"https://github.com/Hub-OS/documentation-website/tree/master/docs/01-client/04-lua-api/01-lua-cheat-sheet.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"clientSidebar","previous":{"title":"Type Definitions","permalink":"/client/lua-api/type-definitions"},"next":{"title":"Entity","permalink":"/client/lua-api/entity-api/entity"}}');var a=t(4848),l=t(8453);const s={},r="Lua Cheat Sheet",o={},d=[{value:"Variables",id:"variables",level:2},{value:"Functions",id:"functions",level:2},{value:"Globals",id:"globals",level:2},{value:"Scopes",id:"scopes",level:2},{value:"Closures",id:"closures",level:2},{value:"Arrays and Iteration",id:"arrays-and-iteration",level:2},{value:"Conditions",id:"conditions",level:2},{value:"Guard Statements",id:"guard-statements",level:2},{value:"Math",id:"math",level:2},{value:"String Concatination",id:"string-concatination",level:2},{value:"Removing values from a list while iterating",id:"removing-values-from-a-list-while-iterating",level:2},{value:"Appending to a list",id:"appending-to-a-list",level:2},{value:"Random value from a list",id:"random-value-from-a-list",level:2},{value:"Wrapping values from a list",id:"wrapping-values-from-a-list",level:2},{value:"Tables",id:"tables",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"lua-cheat-sheet",children:"Lua Cheat Sheet"})}),"\n",(0,a.jsx)(e.p,{children:"It's not necessary to understand everything on this page, but the more you understand the better you will be at debugging and collaborating."}),"\n",(0,a.jsx)(e.p,{children:"It's best to take just what you need while creating a mod, and come back to study if you're curious."}),"\n",(0,a.jsxs)(e.p,{children:["For an official reference and documentation on standard Lua functions see: ",(0,a.jsx)(e.a,{href:"https://www.lua.org/manual/5.4/",children:"https://www.lua.org/manual/5.4/"})]}),"\n",(0,a.jsx)(e.h2,{id:"variables",children:"Variables"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local a = 1\n\na = a + 1\n\nprint(a) -- 2\n"})}),"\n",(0,a.jsx)(e.h2,{id:"functions",children:"Functions"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local function add(a, b)\n  return a + b\nend\n-- is the same as:\nlocal add = function(a, b)\n  return a + b\nend\n\n-- this may create a global, seen in the next section\nfunction add(a, b)\n  return a + b\nend\n-- is the same as:\nadd = function(a, b)\n  return a + b\nend\n\nprint(add(1, 2)) -- logs 3 in the console\n\n-- multiple return\nlocal function add_multi(a, b, c)\n  return a + c, b + c\nend\n\nlocal a, b = add_multi(1, 2, 3)\nprint(a, b) -- 4 5\n"})}),"\n",(0,a.jsx)(e.h2,{id:"globals",children:"Globals"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function f()\n  -- no local attached, modifies the outside world\n  a = 1\n\n  -- local used, does not modify the outside word\n  local b = 1\n  b = b + 1\nend\n\nf()\nprint(a, b) -- 1 nil\n"})}),"\n",(0,a.jsx)(e.h2,{id:"scopes",children:"Scopes"}),"\n",(0,a.jsx)(e.p,{children:"Access to local variables is limited by scope. This can make it easier to debug by limiting where you need to check for errors related to that variable. It also allows you to avoid unwanted external changes from other parts of your project using a variable with the same name."}),"\n",(0,a.jsxs)(e.p,{children:["Generally if a section of code ends with ",(0,a.jsx)(e.code,{children:"end"}),", it qualifies as a scope."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"for i = 1, 5 do -- scope start\n  if true then -- scope start\n    local c = 1\n    print(i) -- 1-5\n\n    local i = 1\n    print(i) -- 1, shadows the other i variable\n  end -- end scope\n\n  print(i) -- 1-5\n  print(c) -- nil, not in scope\nend -- end scope\n\nprint(i) -- nil, not in scope\n"})}),"\n",(0,a.jsx)(e.h2,{id:"closures",children:"Closures"}),"\n",(0,a.jsx)(e.p,{children:"Variables from a scope can escape by using a closure."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"function create_closure()\n  local v = 1\n\n  local function inc()\n    -- updates v for everyone\n    v = v + 1\n  end\n\n  local function get()\n    -- sees the updated value of v, even when inc updates it later\n    return v\n  end\n\n  return inc, get\nend\n\nlocal inc, get = create_closure()\ninc()\ninc()\nprint(get()) -- 2\n\nlocal inc2, get2 = create_closure()\ninc2()\nprint(get(), get2()) -- 2 1\n"})}),"\n",(0,a.jsx)(e.h2,{id:"arrays-and-iteration",children:"Arrays and Iteration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- logs 1 through 5\nfor i = 1, 5 do\n  print(i)\nend\n\n-- logs 5 through 1\nfor i = 5, 1, -1 do\n  print(i)\nend\n\n-- logs 1 and 3, we skipped two by incrementing by 2\nfor i = 1, 5, 2 do\n  print(i)\nend\n\nlocal list = {"a", "b", "c"}\n\nprint(#list) -- 3, # is used to get the length of a list\n\n-- prints "a", then "b", then "c"\nfor i = 1, #list do\n  print(list[i])\nend\n\n-- prints "a", then "b", then "c"\nfor i, value in ipairs(list) do\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"conditions",children:"Conditions"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- nil and false are "falsy":\n\nif nil then\n  print("this never executes")\nend\n\nif false then\n  print("this never executes")\nend\n\n-- everything else is truthy:\n\nlocal f = function() end\n\nif true and 0 and "" and {} and f then\n  print("this executes")\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"guard-statements",children:"Guard Statements"}),"\n",(0,a.jsx)(e.p,{children:"Guard statements allow you to avoid nesting, which prevents code from travelling to the right and reduces the amount of overlapping scopes you need to be aware of while debugging."}),"\n",(0,a.jsx)(e.p,{children:"The trade off is taller code, but it's generally easier to understand when more conditions are added."}),"\n",(0,a.jsx)(e.p,{children:"Popular videos on the topic:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://www.youtube.com/watch?v=CFRhGnuXG-4",children:"https://www.youtube.com/watch?v=CFRhGnuXG-4"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://www.youtube.com/watch?v=-AzSRHiV9Cc",children:"https://www.youtube.com/watch?v=-AzSRHiV9Cc"})}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function nested(x, y)\n  local tile = Field.tile_at(x, y)\n\n  if tile and tile:is_walkable() then\n    local next_tile = tile:get_tile(tile:facing(), 1)\n\n    if next_tile and next_tile:is_walkable() then\n      print("hello!")\n    end\n  end\nend\n-- vs\nfunction guarded(x, y)\n  local tile = Field.tile_at(x, y)\n\n  if tile and tile:is_walkable() then\n    -- the rest of the function is skipped, and no values are returned\n    -- making sure your inputs are valid and exiting early otherwise is called a guard\n    return\n  end\n\n  local next_tile = tile:get_tile(tile:facing(), 1)\n\n  if next_tile and next_tile:is_walkable() then\n    print("hello!")\n  end\nend\n\nfor _, e in ipairs(entities) do\n  if not e:deleted() then\n    local next_tile = e:get_tile(e:facing(), 1)\n\n    if next_tile and next_tile:is_walkable() then\n      print("hello!")\n    end\n  end\nend\n-- vs\nfor _, e in ipairs(entities) do\n  if e:deleted() then\n    -- skips to the ::continue:: label\n    goto continue\n  end\n\n  local next_tile = e:get_tile(e:facing(), 1)\n\n  if next_tile and next_tile:is_walkable() then\n    print("hello!")\n  end\n\n  ::continue::\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"math",children:"Math"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"print(1 + 1) -- 2\nprint(1 - 1) -- 0\nprint(2 ^ 4) -- 16.0, 2 to the power of 4\nprint(10 / 3) -- 3.333\nprint(10 // 3) -- 3, integer division\nprint(5 % 3) -- 2, the remainder of division\n\nprint(1 - 1 * 3) -- -2, operator precedence\nprint((1 - 1) * 3) -- 0\n\nprint(math.max(1, 2, 3)) -- 3, picks the larger number\nprint(math.min(1, 2, 3)) -- 1, picks the smaller number\n\nprint(math.ceil(1.1)) -- 2\nprint(math.floor(1.1)) -- 1\n\n-- bitwise operations, lua works on 64 bit numbers, but we'll use 4 bits to simplify\n-- 1 = 0001\n-- 2 = 0010\n-- 3 = 0011\n-- 4 = 0100\n-- 5 = 0101\n-- 6 = 0110\n-- 7 = 0111\nprint(1 & 1) -- 1, last bit was 1 in both\nprint(1 & 2) -- 0, no bits were 1 in the same column\nprint(1 & 3) -- 1, the last bit was 1 in both\nprint(3 & 2) -- 2, the second to last bit was 1 in both\nprint(3 & 7) -- 3, every bit in 3 matched against a bit in 7\n\nprint(1 | 2) -- 3, enabled the last two bits\nprint(1 | 3) -- 3, the matching bit was already on in 3\nprint(3 | 2) -- 3, the matching bit was already on in 3\n\nprint(~0) -- inverts bits, every bit is on in this number\nprint(~1) -- every bit except the last bit is on\nprint(3 ~ 2) -- 1, the matching bit was disabled and preserved the rest\nprint(3 ~ 1) -- 2, the matching bit was disabled and preserved the rest\nprint(7 ~ 3) -- 4, disabled matching bits and preserved the rest\nprint(3 ~ 7) -- 4, disabled matching bits and preserved the rest\n\nprint(7 & ~1) -- 6, inverted 1 so only other bits could pass / every bit in 1 was disabled\nprint(7 & ~3) -- 4, inverted 3 so only other bits could pass / every bit in 3 was disabled\n\n-- hexadecimal\nprint(0xff) -- 255\n"})}),"\n",(0,a.jsx)(e.h2,{id:"string-concatination",children:"String Concatination"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'print("a".."b") -- "ab"\nprint("a"..1) -- "a1"\nprint(1.."b") -- error, but due to 1. parsing as 1.0\nprint(1 .."b") -- "1b", any separation or avoiding a literal value helps\nprint("a"..false) -- everything else errors\n\n-- print accepts multiple values and will separate with a tab\nprint("a", "b") -- ~"a b"\n'})}),"\n",(0,a.jsx)(e.h2,{id:"removing-values-from-a-list-while-iterating",children:"Removing values from a list while iterating"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\n-- incorrect: prints "a" -> "c" -> "nil", before creating an out of bounds error\nfor i = 1, #list do\n  print(list[i])\n  table.remove(list, i)\nend\n\nlist = {"a", "b", "c"}\n\n-- iterating in reverse to avoid issues with and reduced performance from shifting O(n)\n-- prints "c" -> "b" -> "a"\nfor i = #list, 1, -1 do\n  print(list[i])\n  table.remove(list, i)\nend\n\nlist = {"a", "b", "c"}\n\n-- advanced: swap remove, zero performance penalty from shifting: O(1), but this can change the order of your list\n-- prints "c" -> "b" -> "a"\nfor i = #list, 1, -1 do\n  local value = list[i]\n\n  list[i] = list[#list] -- move the last value to the current index\n  list[#list] = nil -- setting the last element to nil shrinks the list\n\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"appending-to-a-list",children:"Appending to a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {}\n\ntable.insert(list, "a") -- appends to the end\ntable.insert(list, "b") -- appends to the end\ntable.insert(list, 1, "c") -- inserts at 1, shifts everything at that position to the right\nlist[#list + 1] = "d" -- also appends to the end by setting the value at the next index\nlist[#list + 2] = "e" -- creates a gap and does not properly append\n\n-- "c" -> "a" -> "b" -> "d"\nfor _, value in ipairs(list) do\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"random-value-from-a-list",children:"Random value from a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\nprint(list[math.random(#list)])\n'})}),"\n",(0,a.jsx)(e.h2,{id:"wrapping-values-from-a-list",children:"Wrapping values from a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\n-- "a" -> "b" -> "c" repeating\nfor i = 1, 6 do\n  print(list[(i - 1) % #list + 1])\nend\n'})}),"\n",(0,a.jsx)(e.h2,{id:"tables",children:"Tables"}),"\n",(0,a.jsx)(e.p,{children:"Similar syntax to lists, as lists are a feature of tables."}),"\n",(0,a.jsx)(e.p,{children:'Tables can store values with a key. If the key is a number within a sequence starting at 1, it will be stored in the "list" part of the table.'}),"\n",(0,a.jsx)(e.p,{children:"You can delete keys by setting its value to nil."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local key = "b"\nlocal t = { a = 1, [key] = 2, ["Key with spaces"] = 3 }\n\nprint(t["a"], t["b"], t["Key with spaces"]) -- 1 2 3\nprint(t.a, t.b) -- 1 2\n\nt.f = function() return "hi" end\n-- same as:\nfunction t.f() return "hi" end\n\nprint(t.f()) -- "hi"\n\n\n-- using a colon creates a parameter called self\nfunction t:f() return self.a end\nprint(t.f(t))\n-- same as\nfunction t.f(self) return self.a end\n-- same as\nfunction t.f(input) return input.a end\nprint(t.f(t))\n\n-- using a colon when calling this function will assign the table to the first parameter\nprint(t:f())\n'})})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var i=t(6540);const a={},l=i.createContext(a);function s(n){const e=i.useContext(l);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);