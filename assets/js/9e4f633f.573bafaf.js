"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[8469],{2911:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"client/lua-api/lua-cheat-sheet","title":"Lua Cheat Sheet","description":"It\'s not necessary to understand everything on this page, but the more you understand the better you will be at debugging and collaborating.","source":"@site/docs/01-client/04-lua-api/01-lua-cheat-sheet.md","sourceDirName":"01-client/04-lua-api","slug":"/client/lua-api/lua-cheat-sheet","permalink":"/client/lua-api/lua-cheat-sheet","draft":false,"unlisted":false,"editUrl":"https://github.com/Hub-OS/documentation-website/tree/master/docs/01-client/04-lua-api/01-lua-cheat-sheet.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"clientSidebar","previous":{"title":"Type Definitions","permalink":"/client/lua-api/type-definitions"},"next":{"title":"Entity","permalink":"/client/lua-api/entity-api/entity"}}');var a=t(4848),l=t(8453);const s={},r="Lua Cheat Sheet",o={},d=[{value:"Cheat Sheet",id:"cheat-sheet",level:2},{value:"Variables",id:"variables",level:3},{value:"Functions",id:"functions",level:3},{value:"Globals",id:"globals",level:3},{value:"Scopes",id:"scopes",level:3},{value:"Closures",id:"closures",level:3},{value:"Arrays and Iteration",id:"arrays-and-iteration",level:3},{value:"Conditions",id:"conditions",level:3},{value:"Guard Statements",id:"guard-statements",level:3},{value:"Math",id:"math",level:3},{value:"String Concatination",id:"string-concatination",level:3},{value:"Removing values from a list while iterating",id:"removing-values-from-a-list-while-iterating",level:3},{value:"Appending to a list",id:"appending-to-a-list",level:3},{value:"Random value from a list",id:"random-value-from-a-list",level:3},{value:"Wrapping values from a list",id:"wrapping-values-from-a-list",level:3},{value:"Tables",id:"tables",level:3},{value:"Common Bugs",id:"common-bugs",level:2},{value:"Index Zero",id:"index-zero",level:3},{value:"Zero Indexed Wrapping",id:"zero-indexed-wrapping",level:3},{value:"Attempting to remove items while iterating",id:"attempting-to-remove-items-while-iterating",level:3},{value:"Global Closure Clash",id:"global-closure-clash",level:3}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"lua-cheat-sheet",children:"Lua Cheat Sheet"})}),"\n",(0,a.jsx)(e.p,{children:"It's not necessary to understand everything on this page, but the more you understand the better you will be at debugging and collaborating."}),"\n",(0,a.jsx)(e.p,{children:"It's best to take just what you need while creating a mod, and come back to study if you have questions."}),"\n",(0,a.jsxs)(e.p,{children:["For an official reference and documentation on standard Lua functions see: ",(0,a.jsx)(e.a,{href:"https://www.lua.org/manual/5.4/",children:"https://www.lua.org/manual/5.4/"})]}),"\n",(0,a.jsx)(e.h2,{id:"cheat-sheet",children:"Cheat Sheet"}),"\n",(0,a.jsx)(e.h3,{id:"variables",children:"Variables"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local a = 1\n\na = a + 1\n\nprint(a) -- 2\n"})}),"\n",(0,a.jsx)(e.h3,{id:"functions",children:"Functions"}),"\n",(0,a.jsxs)(e.p,{children:["You should prefer to use ",(0,a.jsx)(e.code,{children:"local"})," on functions (see ",(0,a.jsx)(e.a,{href:"#scopes",children:"Scopes"}),"). This does not include ",(0,a.jsx)(e.code,{children:"*_init"})," functions they must be visible to the engine."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local function add(a, b)\n  return a + b\nend\n-- is the same as:\nlocal add = function(a, b)\n  return a + b\nend\n\n-- this may create a global, seen in the next section\nfunction add(a, b)\n  return a + b\nend\n-- is the same as:\nadd = function(a, b)\n  return a + b\nend\n\nprint(add(1, 2)) -- logs 3 in the console\n\n-- multiple return\nlocal function add_multi(a, b, c)\n  return a + c, b + c\nend\n\nlocal a, b = add_multi(1, 2, 3)\nprint(a, b) -- 4 5\n"})}),"\n",(0,a.jsx)(e.h3,{id:"globals",children:"Globals"}),"\n",(0,a.jsxs)(e.p,{children:["You should prefer to use local wherever possible (see ",(0,a.jsx)(e.a,{href:"#scopes",children:"Scopes"}),")"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local function f()\n  -- no local attached, modifies the outside world\n  a = 1\n\n  -- local used, does not modify the outside word\n  local b = 1\n  b = b + 1\nend\n\nf()\nprint(a, b) -- 1 nil\n"})}),"\n",(0,a.jsx)(e.h3,{id:"scopes",children:"Scopes"}),"\n",(0,a.jsxs)(e.p,{children:["Access to local variables is limited by scope. This can make it easier to debug by reducing where you need to check for errors related to that variable. It also allows you to avoid unwanted external changes from other parts (or even the ",(0,a.jsx)(e.a,{href:"#global-closure-clash",children:"same part"}),"!) of your project using a variable with the same name."]}),"\n",(0,a.jsxs)(e.p,{children:["Generally if a section of code ends with ",(0,a.jsx)(e.code,{children:"end"}),", it qualifies as a scope."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"for i = 1, 5 do -- scope start\n  if true then -- scope start\n    local c = 1\n    print(i) -- 1-5\n\n    local i = 1\n    print(i) -- 1, shadows the other i variable\n  end -- end scope\n\n  print(i) -- 1-5\n  print(c) -- nil, not in scope\nend -- end scope\n\nprint(i) -- nil, not in scope\n"})}),"\n",(0,a.jsx)(e.h3,{id:"closures",children:"Closures"}),"\n",(0,a.jsx)(e.p,{children:"Variables from a scope can escape by using a closure."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local function create_closures()\n  local v = 1\n\n  -- function that accesses / "captures" an external local variable\n  -- this is called a closure\n  local function inc()\n    -- updates v for everyone\n    v = v + 1\n  end\n\n  -- another closure\n  local function get()\n    -- sees the updated value of v, even when inc updates it later\n    return v\n  end\n\n  -- these functions escape the scope of create_closures, keeping v alive and accessible\n  return inc, get\nend\n\nlocal inc, get = create_closures()\ninc()\ninc()\nprint(get()) -- 2\n\nlocal inc2, get2 = create_closures()\ninc2()\nprint(get(), get2()) -- 2 1\n'})}),"\n",(0,a.jsx)(e.h3,{id:"arrays-and-iteration",children:"Arrays and Iteration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- logs 1 through 5\nfor i = 1, 5 do\n  print(i)\nend\n\n-- logs 5 through 1\nfor i = 5, 1, -1 do\n  print(i)\nend\n\n-- logs 1 and 3, we skipped two by incrementing by 2\nfor i = 1, 5, 2 do\n  print(i)\nend\n\nlocal list = {"a", "b", "c"}\n\nprint(#list) -- 3, # is used to get the length of a list\n\n-- prints "a", then "b", then "c"\nfor i = 1, #list do\n  print(list[i])\nend\n\n-- prints "a", then "b", then "c"\nfor i, value in ipairs(list) do\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"conditions",children:"Conditions"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'-- nil and false are "falsy":\n\nif nil then\n  print("this never executes")\nend\n\nif false then\n  print("this never executes")\nend\n\n-- everything else is truthy:\n\nlocal f = function() end\n\nif true and 0 and "" and {} and f then\n  print("this executes")\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"guard-statements",children:"Guard Statements"}),"\n",(0,a.jsx)(e.p,{children:"Guard statements allow you to avoid nesting, which prevents code from travelling to the right and reduces the amount of overlapping scopes you need to be aware of while debugging."}),"\n",(0,a.jsx)(e.p,{children:"The trade off is taller code, but it's generally easier to understand when more conditions are added."}),"\n",(0,a.jsx)(e.p,{children:"Popular videos on the topic:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://www.youtube.com/watch?v=CFRhGnuXG-4",children:"https://www.youtube.com/watch?v=CFRhGnuXG-4"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://www.youtube.com/watch?v=-AzSRHiV9Cc",children:"https://www.youtube.com/watch?v=-AzSRHiV9Cc"})}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'function nested(x, y)\n  local tile = Field.tile_at(x, y)\n\n  if tile and tile:is_walkable() then\n    local next_tile = tile:get_tile(tile:facing(), 1)\n\n    if next_tile and next_tile:is_walkable() then\n      print("hello!")\n    end\n  end\nend\n-- vs\nfunction guarded(x, y)\n  local tile = Field.tile_at(x, y)\n\n  if tile and tile:is_walkable() then\n    -- the rest of the function is skipped, and no values are returned\n    -- making sure your inputs are valid and exiting early otherwise is called a guard\n    return\n  end\n\n  local next_tile = tile:get_tile(tile:facing(), 1)\n\n  if next_tile and next_tile:is_walkable() then\n    print("hello!")\n  end\nend\n\nfor _, e in ipairs(entities) do\n  if not e:deleted() then\n    local next_tile = e:get_tile(e:facing(), 1)\n\n    if next_tile and next_tile:is_walkable() then\n      print("hello!")\n    end\n  end\nend\n-- vs\nfor _, e in ipairs(entities) do\n  if e:deleted() then\n    -- skips to the ::continue:: label\n    goto continue\n  end\n\n  local next_tile = e:get_tile(e:facing(), 1)\n\n  if next_tile and next_tile:is_walkable() then\n    print("hello!")\n  end\n\n  ::continue::\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"math",children:"Math"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"print(1 + 1) -- 2\nprint(1 - 1) -- 0\nprint(2 * 3) -- 6\nprint(10 / 3) -- 3.333\nprint(10 // 3) -- 3, integer division\nprint(5 % 3) -- 2, the remainder of division\nprint(2 ^ 4) -- 16.0, 2 to the power of 4\n\nprint(1 - 1 * 3) -- -2, operator precedence\nprint((1 - 1) * 3) -- 0\n\nprint(math.max(1, 2, 3)) -- 3, picks the larger number\nprint(math.min(1, 2, 3)) -- 1, picks the smaller number\n\nprint(math.ceil(1.1)) -- 2\nprint(math.floor(1.1)) -- 1\n\n-- bitwise operations, lua works on 64 bit numbers, but we'll use 4 bits to simplify\n-- 1 = 0001\n-- 2 = 0010\n-- 3 = 0011\n-- 4 = 0100\n-- 5 = 0101\n-- 6 = 0110\n-- 7 = 0111\n\n-- bitwise and, it's like an `and` operation on every bit\nprint(1 & 1) -- 1, last bit was 1 in both\nprint(1 & 2) -- 0, no bits were 1 in the same column\nprint(1 & 3) -- 1, the last bit was 1 in both\nprint(3 & 2) -- 2, the second to last bit was 1 in both\nprint(3 & 7) -- 3, every bit in 3 matched against a bit in 7\n\n-- bitwise or, similar to an `or` operation on all bits\nprint(1 | 2) -- 3, enabled the last two bits\nprint(1 | 3) -- 3, the matching bit was already on in 3\nprint(3 | 2) -- 3, the matching bit was already on in 3\n\n-- unary bitwise not, similar to `not value` on all bits\nprint(~0) -- inverts bits, every bit is on in this number\nprint(~1) -- every bit except the last bit is on\n\n-- bitwise xor\nprint(3 ~ 2) -- 1, the matching bit was disabled and preserved the rest\nprint(3 ~ 1) -- 2, the matching bit was disabled and preserved the rest\nprint(7 ~ 3) -- 4, disabled matching bits and preserved the rest\nprint(3 ~ 7) -- 4, disabled matching bits and preserved the rest\n\n-- combining bitwise `and` with `not` to disable bits\nprint(7 & ~1) -- 6, inverted 1 so only other bits could pass / every bit in 1 was disabled\nprint(7 & ~3) -- 4, inverted 3 so only other bits could pass / every bit in 3 was disabled\n\n-- bit shift\nprint(6 >> 1) -- 3, shifted bits to the right by 1: 0110 -> 0011\nprint(4 >> 2) -- 1, shifted bits to the right by 2: 0110 -> 0001\nprint(1 << 1) -- 2, shifted bits to the left by 1: 0001 -> 0010\nprint(1 << 2) -- 4, shifted bits to the left by 2: 0001 -> 0100\n\n-- hexadecimal\nprint(0xff) -- 255\n"})}),"\n",(0,a.jsx)(e.h3,{id:"string-concatination",children:"String Concatination"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'print("a".."b") -- "ab"\nprint("a"..1) -- "a1"\nprint(1.."b") -- error, but due to 1. parsing as 1.0\nprint(1 .."b") -- "1b", any separation or avoiding a literal value helps\nprint("a"..false) -- everything else errors\n\n-- print accepts multiple values and will separate with a tab\nprint("a", "b") -- ~"a b"\n'})}),"\n",(0,a.jsx)(e.h3,{id:"removing-values-from-a-list-while-iterating",children:"Removing values from a list while iterating"}),"\n",(0,a.jsxs)(e.p,{children:["Watch out for ",(0,a.jsx)(e.a,{href:"#attempting-to-remove-items-while-iterating",children:"this"})," issue."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\n-- iterating in reverse to avoid issues with and reduced performance from shifting O(n)\n-- prints "c" -> "b" -> "a"\nfor i = #list, 1, -1 do\n  print(list[i])\n  table.remove(list, i)\nend\n\nlist = {"a", "b", "c"}\n\n-- advanced: swap remove, zero performance penalty from shifting: O(1), but this can change the order of your list\n-- prints "c" -> "b" -> "a"\nfor i = #list, 1, -1 do\n  local value = list[i]\n\n  list[i] = list[#list] -- move the last value to the current index\n  list[#list] = nil -- setting the last element to nil shrinks the list\n\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"appending-to-a-list",children:"Appending to a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {}\n\ntable.insert(list, "a") -- appends to the end\ntable.insert(list, "b") -- appends to the end\ntable.insert(list, 1, "c") -- inserts at 1, shifts everything at that position to the right\nlist[#list + 1] = "d" -- also appends to the end by setting the value at the next index\nlist[#list + 2] = "e" -- creates a gap and does not properly append\n\n-- "c" -> "a" -> "b" -> "d"\nfor _, value in ipairs(list) do\n  print(value)\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"random-value-from-a-list",children:"Random value from a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\nprint(list[math.random(#list)])\n'})}),"\n",(0,a.jsx)(e.h3,{id:"wrapping-values-from-a-list",children:"Wrapping values from a list"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\n-- "a" -> "b" -> "c" repeating\nfor i = 1, 6 do\n  print(list[(i - 1) % #list + 1])\nend\n\n-- same output as above\nfor i = 0, 5 do\n  print(list[i % #list + 1])\nend\n\n-- same output as above\nlocal i = 1\n\nfor _ = 1, 6 do\n  print(list[i])\n  -- resolve the next index\n  i = i % #list + 1\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"tables",children:"Tables"}),"\n",(0,a.jsx)(e.p,{children:"Similar syntax to lists, as lists are a feature of tables."}),"\n",(0,a.jsx)(e.p,{children:'Tables can store values with a key. If the key is a number within a sequence starting at 1, it will be stored in the "list" part of the table.'}),"\n",(0,a.jsx)(e.p,{children:"You can delete keys by setting its value to nil."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local key = "b"\nlocal t = { a = 1, [key] = 2, ["Key with spaces"] = 3 }\n\nprint(t["a"], t["b"], t["Key with spaces"]) -- 1 2 3\nprint(t.a, t.b) -- 1 2\n\n-- defining a function on a table key, note adding local is unnecessary and will cause errors\n-- as the function will be already tied to the table\nt.f = function() return "hi" end\n-- same as:\nfunction t.f() return "hi" end\n\nprint(t.f()) -- "hi"\n\n\n-- using a colon creates a parameter called self\nfunction t:f() return self.a end\nprint(t.f(t))\n-- same as\nfunction t.f(self) return self.a end\n-- same as\nfunction t.f(input) return input.a end\nprint(t.f(t))\n\n-- using a colon when calling this function will assign the table to the first parameter\nprint(t:f())\n'})}),"\n",(0,a.jsx)(e.h2,{id:"common-bugs",children:"Common Bugs"}),"\n",(0,a.jsx)(e.h3,{id:"index-zero",children:"Index Zero"}),"\n",(0,a.jsx)(e.p,{children:"In most programming languages, lists start at zero. In lua lists start at one."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local list = { 5 }\nprint(list[0]) -- nil\nprint(list[1]) -- 5\n"})}),"\n",(0,a.jsx)(e.h3,{id:"zero-indexed-wrapping",children:"Zero Indexed Wrapping"}),"\n",(0,a.jsxs)(e.p,{children:["For correct examples, click ",(0,a.jsx)(e.a,{href:"#wrapping-values-from-a-list",children:"here"}),"."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"-- attempting to wrap around the list as if we're using a zero indexed language\nprint(list[3 % #list]) -- nil\n"})}),"\n",(0,a.jsx)(e.h3,{id:"attempting-to-remove-items-while-iterating",children:"Attempting to remove items while iterating"}),"\n",(0,a.jsxs)(e.p,{children:["For correct examples, click ",(0,a.jsx)(e.a,{href:"#removing-values-from-a-list-while-iterating",children:"here"}),"."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:'local list = {"a", "b", "c"}\n\n-- incorrect: prints "a" -> "c" -> "nil", before creating an out of bounds error\nfor i = 1, #list do\n  print(list[i])\n  table.remove(list, i)\nend\n'})}),"\n",(0,a.jsx)(e.h3,{id:"global-closure-clash",children:"Global Closure Clash"}),"\n",(0,a.jsxs)(e.p,{children:["For correct examples, click ",(0,a.jsx)(e.a,{href:"#closures",children:"here"}),"."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-lua",children:"local function create_closure()\n  local v = 0\n\n  -- note: given a name and missing local\n  -- this is the same as `get_and_inc = function()`, meaning we're working with a global variable\n  function get_and_inc()\n    v = v + 1\n    return v\n  end\n\n  return function()\n    -- since local wasn't used, we're really accessing a global here\n    return get_and_inc()\n  end\nend\n\nlocal get_and_inc1 = create_closure()\nlocal get_and_inc2 = create_closure()\n\nprint(get_and_inc1()) -- 1\nprint(get_and_inc1()) -- 2\nprint(get_and_inc2()) -- 3 this isn't intended!\n"})})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var i=t(6540);const a={},l=i.createContext(a);function s(n){const e=i.useContext(l);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);